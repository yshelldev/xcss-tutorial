# Creating and Extending Variants in XCSS

This tutorial shows how to extend variants of an existing symbolic class (sym-class) by leveraging exposed CSS variables, enabling dynamic theming and style variations.

## Take a look in Practice, (Using a Summon Sym-Class as a Preview Container)

```html
<!-- Use a summon symclass as preview container. -->
 
<summon demo$varient-preview="= d-flex gap-12;"> 
<!-- Cascade conflicts does't affect this because specifity is taken advantage off. -->
<button 
class="~demo$$button ~demo$button-varients-1" demo$button-varients-1="
	&[x-preset-1] {
		--button_color: #ffe17d;
		--button_outline_color: #491505;
	}
	&[x-preset-2] {
		--button_color: #b3fff9;
		--button_outline_color: #495f7a;
	}
" 
x-preset-1
> <!-- While composing symclass in this manner, all variables are detected, and autosuggests them. -->
  <span> Click Me </span>
</button>


<!-- XCSS provieds a special operator called `de-nest`, it helps in much better organization of nested strucures. -->
<button 
class="~demo$$button =demo$button-varients-2" demo$button-varients-2="
	&[x-preset-]& {
		&[1] {
			--button_color: #ffe17d;
			--button_outline_color: #491505;
		}
		&[2] {
			--button_color: #b3fff9;
			--button_outline_color: #495f7a;
		}
	}
" 
x-preset-2
> <!-- While composing symclass in this manner, all variables are detected, and autosuggests them. -->
  <span> Click Me </span>
</button>


<!-- For runtime dynamic styling update the variable using style attribute. -->
<button 
class="~demo$$button"
style="--button_color: #8cff7d; --button_outline_color: #354905;"
> <span> Click Me </span> </button>

</summon>
```


- The first button extends demo$$button by declaring variant styles using attribute selectors like `[x-preset-1]` and `[x-preset-2]`.
- The second button demonstrates using the de-nest operator for better nested structure organization, generating variants based on nested selectors.

### De-nest Operator, (destructive nesting)

The de-nest operator improves nesting by merging parent and child selectors using the `&` parent reference character.
How it Works

- Child selectors must begin with `&`.
- The parent selector must end with one or more `&` characters (denoted n, where n â‰¥ 1).
- When merging, exactly n characters are removed from the end of the parent selector and the beginning of the child selector (excluding `&`), then concatenated.

#### Important Limitation

This operator does not support comma-separated multiple nested selectors properly.

```css
/* Input */
[a-]& { 
  &[b], &[c] { ... } 
}

/* Expected output */
[a-b] { ... }
[a-c] { ... }

/* Actual output */
[a-b], &[c] { ... } 
/* Incorrect: second selector fails */
```

The parent reference `&` does not expand correctly in comma-separated lists, so use this operator cautiously with complex multi-selector cases.

This system allows automatic variable detection and autosuggestions when composing variants, making it easier to create flexible, maintainable component themes with clean scoped styles.